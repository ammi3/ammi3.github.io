---
title: 算法小结：排序算法
date: 2021-04-16 22:31:40
tags:
---


### 1. 初级排序算法
<!--more-->
#### 1.1 选择排序

> 步骤：首先，找到数组中最小的那个元素，将其和数组的第一个元素交换位置；其次，在剩下的元素中找到最小的元素，将其和数组的第二个元素交换位置，直至将整个数组排序。

```C
void selectSort(int arr[], int n)
{
    for (int i = 0; i < n - 1; i++)
    {
        int minIndex = i;

        for (int j = i + 1; j < n; j++)
        {
            if (arr[j] < arr[minIndex])
            {
                minIndex = j;
            }
        }

        if (i != minIndex)
        {
            int temp = arr[i];
            arr[i] = arr[minIndex];
            arr[minIndex] = temp;
        }
    }
}
```

｜分析

1. 每次交换都能够排定一个元素，因此交换的总次数为N，所以该算法的**时间效率取决于比较的次数**

2. 我们假设一个长度为N的数组，求其选择排序大约需要的比较次数与交换次数

   1. 由于选择排序需要对当前元素**与其之后的所有元素进行比较**并与最小值进行交换。

   2. 故：第一个元素需要比较N-1次，交换1次；第二个元素需要比较N-2次，交换一次...

   3. 即：总共有N^2次比较，N次交换
      $$
      (N-1)+(N-2)+(N-3)+...+2+1=N(N-1)/2 \approx N^2/2
      $$

｜总结

1. 运行时间和输入无关。第一次的扫描整个数组并不能为下一遍扫描提供有用的信息。
2. 数据移动是最少的。每次交换都会改变两个数组元素的值，确定一个位置。交换次数与数组大小成线性关系。

#### 1.2 插入排序

插入排序与选择排序一样，其**当前索引左边的所有元素都是有序的**。但在插入排序中它们的最终位置是不确定的，若按照从小到大排序，那么可能为了给比其更小的元素让出位置，它们还有被移动的可能。

> 步骤：对于当前元素arr[i]，将它与它之前的所有元素arr[0:i]相比较，直到碰到**第一个**小于当前元素的元素arr[j]，交换位置。此时arr[0:i]局部有序。

```c
void insertSort(int arr[], int n)
{
    for (int i = 1; i < n; i++)
    {
        for (int j = i; j > 0 && arr[j] < arr[j - 1]; j--)
        {
            int temp = arr[j];
            arr[j] = arr[j - 1];
            arr[j - 1] = temp;
        }
    }
}
```

｜分析

1. 对于当前元素arr[i]，若其左侧元素小于arr[i]，则表示序列arr[0:i]局部有序，不用交换。

2. 假设数组长度为N，求平均情况下需要的比较次数与交换次数，最坏情况与最好情况呢？

3. 最好情况。

   1. 即：需要排序的顺序与给定的顺序一样
   2. 交换次数：0次
   3. 比较次数：N-1次，对于arr[1:N]的每一个元素都要进行一次比较

4. 最坏情况

   1. 即：需要排序的顺序与给定的顺序正好相反

   2. 比较次数：N^2/2次
      $$
      1+2+...+(N-2)+(N-1)=N(N-1)/2 \approx N^2/2
      $$

   3. 交换次数：N^2/2次
      $$
      (N-1)+(N-2)+(N-3)+...+2+1=N(N-1)/2 \approx N^2/2
      $$

5. 平均情况

   1. 比较次数：N^2/4次
   2. 交换次数：N^2/4次

｜总结

1. 运行时间与输入有关
2. 使用插入排序对**部分有序的数组**进行排序效率很高

#### 1.3 希尔排序

希尔排序基于插入排序。由于插入排序对于大规模的乱序数组效率很慢，因为它只能够交换相邻元素，元素只能从数组的一端一步步地移动到另外一端。

> 1. 将该数组分为若干子序列
> 2. 将这些子序列进行插入排序
> 3. 减少每个子序列中元素的距离，直至距离为1

```c
void shellSort(int arr[], int n)
{
    int h = 1;
    while (h < n / 3)
    {
        h = 3 * h + 1;
    }
    while (h >= 1)
    {
        for (int i = h; i < n; i++)
        {
            for (int j = i; j >= h && arr[j] < arr[j - h]; j -= h)
            {
                int temp = arr[j];
                arr[j] = arr[j - h];
                arr[j - h] = temp;
            }
        }
        h = h / 3;
    }
}
```

｜分析

1. 希尔排序更加高效地原因是其权衡了子数组的规模和有序性。排序初期，各个子数组长度很短，而排序之后子数组都部分有序，这两种情况很适合插入排序

｜总结

### 2. 归并排序

要将一个数组排序，可以先将它分成两半分别进行排序

### 3. 快速排序

### 4. 应用